# 測試撰寫指令

## 測試框架規範
- 使用 **Jest** 作為主要測試框架
- 測試檔案命名格式：`*.test.js` 或 `*.spec.js`
- 測試檔案放在 `tests/` 目錄或與源碼同目錄

## 測試結構要求
```javascript
describe('模組或功能名稱', () => {
  beforeEach(() => {
    // 每個測試前的設定
  })

  afterEach(() => {
    // 每個測試後的清理
  })

  describe('特定功能群組', () => {
    it('應該要有明確的測試描述', () => {
      // 測試實作
    })
  })
})
```

## 測試命名規範
- 使用 **繁體中文** 描述測試案例
- 格式：「應該 + 預期行為 + 在特定條件下」
- 範例：`it('應該回傳使用者資料當提供有效的 ID 時', () => {})`

## 測試覆蓋要求
### 必須測試的情境：
-  **正常情況**：有效輸入的正確輸出
-  **邊界條件**：空值、null、undefined、空字串
-  **錯誤處理**：無效輸入的錯誤回應
-  **異常情境**：網路錯誤、超時等

### 測試類型：
- **單元測試**：測試單一函數或方法
- **整合測試**：測試模組間的互動
- **端對端測試**：測試完整的用戶流程

## 斷言風格
- 使用 Jest 的 `expect()` 語法
- 優先使用語義化的 matcher：
  - `toBe()` - 嚴格相等
  - `toEqual()` - 深度比較
  - `toContain()` - 包含檢查
  - `toThrow()` - 異常檢查

## Mock 和 Stub 規範
- 外部依賴必須 mock
- 使用 `jest.fn()` 創建 mock 函數
- 使用 `jest.mock()` mock 整個模組
- 測試後要清理 mock：`jest.clearAllMocks()`

## 非同步測試
- 使用 `async/await` 語法
- 適當設定 timeout
- 測試 Promise 的 resolve 和 reject 情況

## 測試資料管理
- 使用 factory 函數生成測試資料
- 避免硬編碼的測試資料
- 每個測試要獨立，不依賴其他測試的結果

## 效能和品質
- 測試應該快速執行（單個測試 < 100ms）
- 避免不必要的複雜設定
- 測試碼也要保持可讀性和可維護性
- 目標測試覆蓋率：80% 以上